@prefix schema: <http://schema.org/> .
@prefix ex:    <http://topbraid.org/examples/shaclsquare#> .
@prefix sh:    <http://www.w3.org/ns/shacl#> .
@prefix rdf:   <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix owl:   <http://www.w3.org/2002/07/owl#> .
@prefix arg:   <http://www.w3.org/ns/shacl/arg#> .
@prefix xsd:   <http://www.w3.org/2001/XMLSchema#> .
@prefix rdfs:  <http://www.w3.org/2000/01/rdf-schema#> .

sh:predicate2  a             rdf:Property ;
        rdfs:label           "predicate 2" ;
        sh:defaultValueType  rdf:Property .

sh:detail  a        rdf:Property ;
        rdfs:label  "detail" .

sh:AbstractPatternNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Specifies a regular expression that all nodes need to match." ;
        rdfs:label             "Abstract pattern constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The optional flags." ;
                                 rdfs:label                "flags" ;
                                 sh:datatype               xsd:string ;
                                 sh:optional               true ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:flags
                               ] ;
        sh:argument            [ rdfs:comment              "The (regular expression) pattern for the focus nodes." ;
                                 rdfs:label                "pattern" ;
                                 sh:datatype               xsd:string ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:pattern
                               ] ;
        sh:message             "Must match the pattern {?pattern}" ;
        sh:validationFunction  sh:hasPattern .

sh:AbstractMinExclusiveNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Specifies an (exclusive) minimum value for literal nodes." ;
        rdfs:label             "Abstract min exclusive constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The exclusive minimum value permitted: ?value > ?minExclusive" ;
                                 rdfs:label                "min exclusive" ;
                                 sh:nodeKind               sh:Literal ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:minExclusive
                               ] ;
        sh:message             "Must be greater than {?minExclusive}" ;
        sh:validationFunction  sh:hasMinExclusive .

sh:sourceConstraint  a  rdf:Property ;
        rdfs:label  "source constraint" .

sh:NativeScope  a        sh:ShapeClass ;
        rdfs:comment     "A scope that has a native executable body attached to it." ;
        rdfs:label       "Native scope" ;
        rdfs:subClassOf  sh:Scope ;
        sh:abstract      true .

sh:hasDirectType  a      sh:Function ;
        rdfs:comment     "Checks whether a given node (?value) has a given class ($directType) as its rdf:type." ;
        rdfs:label       "has direct type" ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment              "The type that all value must have, excluding subclasses." ;
                           rdfs:label                "direct type" ;
                           sh:class                  rdfs:Class ;
                           sh:nodeKind               sh:IRI ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:directType
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "\n\t\tASK {\n\t\t\t$value a $directType .\n\t\t}\n\t\t" .

sh:Function  a           sh:ShapeClass ;
        rdfs:comment     "A macro implementing a SPARQL function, backed by a SPARQL ASK or SELECT query." ;
        rdfs:label       "Function" ;
        rdfs:subClassOf  sh:Macro , sh:SPARQLExecutable .

sh:arg1  a          rdf:Property ;
        rdfs:label  "arg1" .

sh:Violation  a       sh:Severity ;
        rdfs:comment  "The severity of error-level results." ;
        rdfs:label    "Violation" .

xsd:double  a            rdfs:Datatype ;
        rdfs:label       "double" ;
        rdfs:subClassOf  rdfs:Literal .

sh:ResultAnnotation  a   sh:ShapeClass ;
        rdfs:comment     "Defines the rules to derive the values of a given annotation property as extra values for a constraint violation." ;
        rdfs:label       "Result annotation" ;
        rdfs:subClassOf  rdfs:Resource ;
        sh:property      [ rdfs:comment  "The name of the SPARQL variable from the SELECT clause that shall be used for the values." ;
                           rdfs:label    "annotation variable name" ;
                           sh:datatype   xsd:string ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:annotationVarName
                         ] ;
        sh:property      [ rdfs:comment  "The values of the annotation property." ;
                           rdfs:label    "annotation value" ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:annotationValue
                         ] ;
        sh:property      [ rdfs:comment  "The annotation property that shall be set." ;
                           rdfs:label    "annotation property" ;
                           sh:class      rdf:Property ;
                           sh:maxCount   1 ;
                           sh:minCount   1 ;
                           sh:predicate  sh:annotationProperty
                         ] .

sh:annotationProperty
        a           rdf:Property ;
        rdfs:label  "annotation property" .

sh:hasMaxExclusive  a    sh:Function ;
        rdfs:comment     "Checks whether a given node (?value) has value less than (<) the provided ?maxExclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types." ;
        rdfs:label       "has max exclusive" ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment  "The permitted exclusive maximum value" ;
                           rdfs:label    "max exclusive" ;
                           sh:nodeKind   sh:Literal ;
                           sh:predicate  sh:maxExclusive
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "ASK { FILTER ($value < $maxExclusive) }" .

sh:AbstractQualifiedMinCountPropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Enforces a constraint that a minimum number of values of the property must have a certain shape." ;
        rdfs:label       "Abstract qualified min count property constraint" ;
        rdfs:subClassOf  sh:AbstractQualifiedCountPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "The minimum number of values that must have the shape." ;
                           rdfs:label                "qualified min count" ;
                           sh:datatype               xsd:integer ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:qualifiedMinCount
                         ] ;
        sh:message       "Violation of qualified value shape constraint {$qualifiedValueShape}: expected at least {$qualifiedMinCount}, found {?count}" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?subject) $predicate ?count ?failure\n\t\tWHERE {\n\t\t\tBIND (sh:valuesWithShapeCount($this, $predicate, $qualifiedValueShape, $shapesGraph) AS ?count) .\n\t\t\tBIND (!bound(?count) AS ?failure) .\n\t\t\tFILTER IF(?failure, true, ?count < $qualifiedMinCount) .\n\t\t}\n\t\t" .

sh:subject  a       rdf:Property ;
        rdfs:label  "subject" .

sh:hasNodeKind  a        sh:Function ;
        rdfs:comment     "Checks whether a given node (?value) has a given sh:NodeKind (?nodeKind). For example, sh:hasNodeKind(42, sh:Literal) = true." ;
        rdfs:label       "has node kind" ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment  "The node kind that the node must have." ;
                           sh:class      sh:NodeKind ;
                           sh:index      1 ;
                           sh:predicate  sh:nodeKind
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "\n\t\tASK {\n\t\t\tFILTER ((isIRI($value) && $nodeKind = sh:IRI) ||\n\t\t\t\t(isLiteral($value) && $nodeKind = sh:Literal) ||\n\t\t\t\t(isBlank($value) && $nodeKind = sh:BlankNode)) .\n\t\t}\n\t\t" .

sh:severity  a      rdf:Property ;
        rdfs:label  "severity" .

sh:qualifiedValueShape
        a                    rdf:Property ;
        rdfs:label           "qualified value shape" ;
        sh:defaultValueType  sh:Shape .

rdfs:Literal  a          rdfs:Class ;
        rdfs:comment     "The class of literal values, eg. textual strings and integers." ;
        rdfs:label       "Literal" ;
        rdfs:subClassOf  rdfs:Resource .

sh:AbstractMaxInclusivePropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Specifies an (inclusive) maximum value for literal values." ;
        rdfs:label             "Abstract max inclusive property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The inclusive maximum value permitted for this property: ?value <= ?maxInclusive" ;
                                 rdfs:label                "max inclusive" ;
                                 sh:nodeKind               sh:Literal ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:maxInclusive
                               ] ;
        sh:message             "Values must be less than or equal to {?maxInclusive}" ;
        sh:validationFunction  sh:hasMaxInclusive .

sh:AbstractMinInclusivePropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Specifies an (inclusive) minimum value for literal values." ;
        rdfs:label             "Abstract min inclusive property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The inclusive minimum value permitted for this property: ?value >= ?minInclusive" ;
                                 rdfs:label                "min inclusive" ;
                                 sh:nodeKind               sh:Literal ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:minInclusive
                               ] ;
        sh:message             "Values must be greater than or equal to {?minInclusive}" ;
        sh:validationFunction  sh:hasMinInclusive .

sh:arg7  a          rdf:Property ;
        rdfs:label  "arg7" .

sh:minExclusive  a  rdf:Property ;
        rdfs:label  "min exclusive" .

sh:valueCount  a       sh:Function ;
        rdfs:comment   "Gets the number of values of a given property (?arg2) at a given subject (?arg1). The result is the number of matches of (?arg1, ?arg2, ?object)." ;
        rdfs:label     "value count" ;
        sh:argument    [ rdfs:comment  "The property to get the value count of." ;
                         sh:class      rdf:Property ;
                         sh:predicate  sh:arg2
                       ] ;
        sh:argument    [ rdfs:comment  "The subject resource." ;
                         sh:class      rdfs:Resource ;
                         sh:predicate  sh:arg1
                       ] ;
        sh:returnType  xsd:integer ;
        sh:sparql      "\n\t\tSELECT ((COUNT(?object)) AS ?result)\n\t\tWHERE {\n\t\t\t$arg1 $arg2 ?object .\n\t\t}\n\t\t" .

sh:property  a               rdf:Property ;
        rdfs:label           "property" ;
        sh:defaultValueType  sh:PropertyConstraint .

sh:annotationValue  a  rdf:Property ;
        rdfs:label  "annotation value" .

sh:labelTemplate  a  rdf:Property ;
        rdfs:label  "label template" .

sh:cachable  a      rdf:Property ;
        rdfs:label  "cachable" .

rdfs:Resource  a    rdfs:Class ;
        rdfs:label  "Resource" .

<http://www.w3.org/ns/shacl>
        rdfs:comment  "The vocabulary defining the Shapes Constraint Language (SHACL)." ;
        rdfs:label    "SHACL Vocabulary" .

sh:AbstractMinLengthNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Specifies the minimum string length of nodes." ;
        rdfs:label             "Abstract min length node constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The minimum string length permitted for the focus nodes." ;
                                 rdfs:label                "min length" ;
                                 sh:datatype               xsd:integer ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:minLength
                               ] ;
        sh:message             "Invalid string length." ;
        sh:validationFunction  sh:hasMinLength .

xsd:date  a              rdfs:Datatype ;
        rdfs:label       "date" ;
        rdfs:subClassOf  rdfs:Literal .

sh:qualifiedMaxCount  a  rdf:Property ;
        rdfs:label  "qualified max count" .

sh:AbstractValidationConstraintTemplate
        a                sh:ShapeClass ;
        rdfs:comment     "A constraint template that points to a function that validates one given value at a time." ;
        rdfs:label       "Abstract validation constraint template" ;
        rdfs:subClassOf  sh:ConstraintTemplate ;
        sh:abstract      true ;
        sh:property      [ rdfs:comment  "A boolean function that takes a given value as its first argument. Additional arguments are passed into the function if their predicate matches the template's arguments. If the function returns true then the value is valid." ;
                           rdfs:label    "validation function" ;
                           sh:class      sh:Function ;
                           sh:maxCount   1 ;
                           sh:minCount   1 ;
                           sh:predicate  sh:validationFunction
                         ] .

sh:validationFunction
        a           rdf:Property ;
        rdfs:label  "validation function" .

sh:PropertyScope  a      sh:ScopeTemplate ;
        rdfs:comment     "A scope that includes all subjects that have at least one value for a given predicate." ;
        rdfs:label       "Property scope" ;
        rdfs:subClassOf  sh:TemplateScope ;
        sh:argument      [ rdfs:comment  "The Property to look for." ;
                           rdfs:label    "predicate" ;
                           sh:class      rdf:Property ;
                           sh:predicate  sh:predicate
                         ] ;
        sh:sparql        "\n\t\tSELECT DISTINCT ?this\n\t\tWHERE {\n\t\t\t?this $predicate ?any .\n\t\t}\n\t\t" .

sh:AbstractDatatypeNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Enforces a constraint that the focus nodes must be literals of a certain datatype." ;
        rdfs:label             "Abstract datatype node constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The datatype that the focus nodes must have. sh:text is recommended if the values shall be either strings or string with language tags." ;
                                 rdfs:label                "datatype" ;
                                 sh:class                  rdfs:Datatype ;
                                 sh:nodeKind               sh:IRI ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:datatype
                               ] ;
        sh:message             "Must have datatype {?datatype}" ;
        sh:validationFunction  sh:hasDatatype .

sh:AbstractMinLengthPropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Specifies the minimum string length of values." ;
        rdfs:label             "Abstract min length property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The minimum string length permitted for values of this property." ;
                                 rdfs:label                "min length" ;
                                 sh:datatype               xsd:integer ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:minLength
                               ] ;
        sh:message             "Invalid string length." ;
        sh:validationFunction  sh:hasMinLength .

sh:hasMaxLength  a       sh:Function ;
        rdfs:comment     "Checks whether a given string (?value) has a length within a given maximum string length." ;
        rdfs:label       "has max length" ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment  "The maximum string length." ;
                           rdfs:label    "max length" ;
                           sh:datatype   xsd:integer ;
                           sh:index      1 ;
                           sh:predicate  sh:maxLength
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "\n\t\tASK {\n\t\t\tBIND (STRLEN(str($value)) AS ?valueLength) .\n\t\t\tFILTER (bound(?valueLength) && ?valueLength <= $maxLength) .\n\t\t}\n\t\t" .

sh:arg2  a          rdf:Property ;
        rdfs:label  "arg2" .

sh:directType  a    rdf:Property ;
        rdfs:label  "direct type" .

sh:hasValue  a      rdf:Property ;
        rdfs:label  "has value" .

sh:derivedValues  sh:defaultValueType  sh:DerivedValuesTemplate .

sh:object  a        rdf:Property ;
        rdfs:label  "object" .

sh:IRI  a             sh:NodeKind ;
        rdfs:comment  "The node kind of all IRIs." ;
        rdfs:label    "IRI" .

sh:AbstractClassPropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Enforces a constraint that all values of the property must be of a certain type. For resources this will accept instances of subclasses. Untyped blank nodes are allowed if a defaultValueType has been specified." ;
        rdfs:label             "Abstract class property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The type that all values of the property must have, based on the semantics defined by the function sh:hasClass." ;
                                 rdfs:label                "class" ;
                                 sh:class                  rdfs:Class ;
                                 sh:nodeKind               sh:IRI ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:class
                               ] ;
        sh:message             "Values must be instances of {?class}" ;
        sh:validationFunction  sh:hasClass .

sh:flags  a         rdf:Property ;
        rdfs:label  "flags" .

sh:AbstractOptionalArgumentConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Enforces a constraint that a non-optional argument must have a value, similar to minCount = 1, unless it has been declared optional, or a sh:defaultValue exists." ;
        rdfs:label       "Abstract optional argument constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment  "The default value of this argument, to be used if no other value has been specified." ;
                           rdfs:label    "default value" ;
                           sh:optional   true ;
                           sh:predicate  sh:defaultValue
                         ] ;
        sh:argument      [ rdfs:comment     "True to indicate that the property does not require a value. By default, the value is required." ;
                           rdfs:label       "optional" ;
                           sh:datatype      xsd:boolean ;
                           sh:defaultValue  false ;
                           sh:predicate     sh:optional
                         ] ;
        sh:argument      [ rdfs:comment     "True to indicate that the property does not require a value when used by a subclass template. If set to true, then instances of subclasses do not need to fill in all required arguments - incomplete templates will simply not be executed. By default, the value is required." ;
                           rdfs:label       "optional when inherited" ;
                           sh:datatype      xsd:boolean ;
                           sh:defaultValue  false ;
                           sh:predicate     sh:optionalWhenInherited
                         ] ;
        sh:message       "Missing value for required argument" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?subject) ?predicate\n\t\tWHERE {\n\t\t\tFILTER (!bound($defaultValue) && !$optional && !$optionalWhenInherited && NOT EXISTS { $this $predicate ?any }) .\n\t\t}\n\t\t" .

sh:inverseValueCount  a  sh:Function ;
        rdfs:comment   "Gets the number of values of a given property (?arg2) at a given object (?arg1). The result is the number of matches of (?subject, ?arg2, ?arg1)." ;
        rdfs:label     "inverse value count" ;
        sh:argument    [ rdfs:comment  "The property to get the value count of." ;
                         sh:class      rdf:Property ;
                         sh:predicate  sh:arg2
                       ] ;
        sh:argument    [ rdfs:comment  "The object resource." ;
                         sh:class      rdfs:Resource ;
                         sh:predicate  sh:arg1
                       ] ;
        sh:returnType  xsd:integer ;
        sh:sparql      "\n\t\tSELECT ((COUNT(?subject)) AS ?result)\n\t\tWHERE {\n\t\t\t?subject $arg2 $arg1 .\n\t\t}\n\t\t" .

sh:LessThanConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Reports an error for any pair of values of the two properties for the same focus node, where the first value is not less than the second value." ;
        rdfs:label       "Less than property pair constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyPairConstraint ;
        sh:message       "Values of {?predicate1} must be less than the values of {?predicate2}" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?subject) ($predicate1 AS ?predicate) ?object\n\t\tWHERE {\n\t\t\t$this $predicate1 ?object .\n\t\t\t$this $predicate2 ?object2 .\n\t\t\tFILTER (!(?object < ?object2)) .\n\t\t}\n\t\t" .

sh:entailment  a    rdf:Property ;
        rdfs:label  "entailment" .

sh:AbstractClassInversePropertyConstraint
        a                      sh:InversePropertyValueConstraintTemplate ;
        rdfs:comment           "Enforces a constraint that all incoming values of the property must be of a certain type. This will accept instances of subclasses.." ;
        rdfs:label             "Abstract class inverse property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The type that all values of the inverse property must have, based on the semantics defined by the function sh:hasClass." ;
                                 rdfs:label                "class" ;
                                 sh:class                  rdfs:Class ;
                                 sh:nodeKind               sh:IRI ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:class
                               ] ;
        sh:message             "Inverse values must be instances of {?class}" ;
        sh:validationFunction  sh:hasClass .

sh:AbstractInPropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Specifies the allowed values for a property by pointing to a List of nodes." ;
        rdfs:label             "Abstract in property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The rdf:List containing the allowed values of the property." ;
                                 rdfs:label                "in" ;
                                 sh:class                  rdf:List ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:in
                               ] ;
        sh:message             "Value is not one of the allowed values" ;
        sh:validationFunction  sh:isIn .

sh:AbstractMaxCountPropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Enforces a constraint on the maximum cardinality of the property." ;
        rdfs:label       "Abstract max count property constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "The maximum number of values that the property can have." ;
                           rdfs:label                "max count" ;
                           sh:datatype               xsd:integer ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:maxCount
                         ] ;
        sh:message       "Required maximum value count {$maxCount} but found {?count}" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?subject) $predicate ?count\n\t\tWHERE {\n\t\t\tBIND (sh:valueCount($this, $predicate) AS ?count) .\n\t\t\tFILTER (?count > $maxCount) .\n\t\t}\n\t\t" .

owl:Ontology  a  rdfs:Class .

sh:NotConstraint  a       sh:ConstraintTemplate ;
        rdfs:comment      "Enforces a constraint that the focus node must not have a given shape, essentially negating the conditions represented by the shape." ;
        rdfs:label        "Not constraint" ;
        rdfs:subClassOf   sh:TemplateConstraint ;
        sh:argument       [ rdfs:comment  "The shape to negate." ;
                            rdfs:label    "shape" ;
                            sh:class      sh:Shape ;
                            sh:predicate  sh:shape
                          ] ;
        sh:labelTemplate  "Not constraint: {?shape}" ;
        sh:message        "Violation of NOT constraint" ;
        sh:sparql         "\n\t\tSELECT $this ?failure\n\t\tWHERE {\n\t\t\tBIND (sh:hasShape($this, $shape, $shapesGraph, true) AS ?hasShape) .\n\t\t\tBIND (!bound(?hasShape) AS ?failure) .\n\t\t\tFILTER (?failure || ?hasShape) .\n\t\t}\n\t\t" .

sh:valuesWithShapeCount
        a              sh:Function ;
        rdfs:comment   "Counts the number of values from a given subject (?arg1) / predicate (?arg2) combination that do not produce any error-level constraint violations for a given shape (?arg3) in a given shapes graph (?arg4). The function produces an error if one of the shapes validated to a fatal error." ;
        rdfs:label     "values with shape count" ;
        sh:argument    [ rdfs:comment  "The shapes graph." ;
                         sh:class      rdfs:Resource ;
                         sh:predicate  sh:arg4
                       ] ;
        sh:argument    [ rdfs:comment  "The shape to validate." ;
                         sh:class      sh:Shape ;
                         sh:predicate  sh:arg3
                       ] ;
        sh:argument    [ rdfs:comment  "The property to count the values of." ;
                         sh:class      rdf:Property ;
                         sh:predicate  sh:arg2
                       ] ;
        sh:argument    [ rdfs:comment  "The subject to count the values of." ;
                         sh:class      rdfs:Resource ;
                         sh:predicate  sh:arg1
                       ] ;
        sh:returnType  xsd:integer ;
        sh:sparql      "\n\t\t# The SUM will fail with an error if one of the operands is not a number\n\t\t# (this mechanism is used to propagate errors from sh:hasShape calls)\n\t\tSELECT (SUM(?s) AS ?result)\n\t\tWHERE {\n\t\t\t{\n\t\t\t\tFILTER NOT EXISTS { $arg1 $arg2 ?value }\n\t\t\t\tBIND (0 AS ?s)\n\t\t\t}\n\t\t\tUNION {\n\t\t\t\tFILTER EXISTS { $arg1 $arg2 ?value }\n\t\t\t\t$arg1 $arg2 ?value .\n\t\t\t\tBIND (sh:hasShape(?value, $arg3, $arg4, true) AS ?hasShape) .\n\t\t\t\tBIND (IF(bound(?hasShape), IF(?hasShape, 1, 0), 'error') AS ?s) .\n\t\t\t}\n\t\t}\n\t\t" .

sh:AbstractMinExclusivePropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Specifies an (exclusive) minimum value for literal values." ;
        rdfs:label             "Abstract min exclusive property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The exclusive minimum value permitted for this property: ?value > ?minExclusive" ;
                                 rdfs:label                "min exclusive" ;
                                 sh:nodeKind               sh:Literal ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:minExclusive
                               ] ;
        sh:message             "Values must be greater than {?minExclusive}" ;
        sh:validationFunction  sh:hasMinExclusive .

sh:AbstractMaxExclusivePropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Specifies an (exclusive) maximum value for literal values." ;
        rdfs:label             "Abstract max exclusive property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The exclusive maximum value permitted for this property: ?value < ?maxExclusive" ;
                                 rdfs:label                "max exclusive" ;
                                 sh:nodeKind               sh:Literal ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:maxExclusive
                               ] ;
        sh:message             "Values must be less than {?maxExclusive}" ;
        sh:validationFunction  sh:hasMaxExclusive .

sh:Macro  a              sh:ShapeClass ;
        rdfs:comment     "Abstract superclass of macro components of a SHACL library, especially Functions and Templates. Macros can take arguments, which are constraints that are different from PropertyConstraints in that they can only have at most one value." ;
        rdfs:label       "Macro" ;
        rdfs:subClassOf  sh:ShapeClass ;
        sh:abstract      true ;
        sh:constraint    [ a             sh:SPARQLConstraint ;
                           rdfs:comment  "The same predicate can only be used once at all Arguments." ;
                           sh:message    "Duplicate Argument for the same predicate {?argPredicate}" ;
                           sh:predicate  sh:argument ;
                           sh:sparql     "\n\t\t\tSELECT $this ($this AS ?subject) (?predicate AS ?argPredicate) (?argument1 AS ?object)\n\t\t\tWHERE {\n\t\t\t\t$this rdfs:subClassOf* ?class1 .\n\t\t\t\t?class1 sh:argument ?argument1 .\n\t\t\t\t?argument1 sh:predicate ?predicate .\n\t\t\t\t$this rdfs:subClassOf* ?class2 .\n\t\t\t\t?class2 sh:argument ?argument2 .\n\t\t\t\tFILTER (?argument1 != ?argument2) .\n\t\t\t\t?argument2 sh:predicate ?predicate .\n\t\t\t}\n\t\t\t"
                         ] ;
        sh:property      [ rdfs:comment  "Declares the argument(s) of this macro." ;
                           rdfs:label    "argument" ;
                           sh:class      sh:Argument ;
                           sh:predicate  sh:argument
                         ] .

sh:annotationVarName  a  rdf:Property ;
        rdfs:label  "annotation var name" .

sh:Warning  a         sh:Severity ;
        rdfs:comment  "The severity of warning-level results." ;
        rdfs:label    "Warning" .

sh:ignoredProperties  a  rdf:Property ;
        rdfs:label  "ignored properties" .

sh:pattern  a       rdf:Property ;
        rdfs:label  "pattern" .

xsd:dateTime  a          rdfs:Datatype ;
        rdfs:label       "dateTime" ;
        rdfs:subClassOf  rdfs:Literal .

sh:countShapesWithMatchResult
        a              sh:Function ;
        rdfs:comment   "Counts the number of shapes from a given rdf:List (?arg2) defined in a given shapes graph (?arg3) where sh:hasShape returns the provided match value (true or false, ?arg4) for a given focus node (?arg1). The function produces a failure if one of the shapes validated to a failure." ;
        rdfs:label     "count shapes with match result" ;
        sh:argument    [ rdfs:comment  "The expected value of sh:hasShape to count." ;
                         sh:datatype   xsd:boolean ;
                         sh:predicate  sh:arg4
                       ] ;
        sh:argument    [ rdfs:comment  "The shapes graph." ;
                         sh:class      rdfs:Resource ;
                         sh:predicate  sh:arg3
                       ] ;
        sh:argument    [ rdfs:comment  "The list of shapes to walk through." ;
                         sh:class      rdf:List ;
                         sh:predicate  sh:arg2
                       ] ;
        sh:argument    [ rdfs:comment  "The focus node." ;
                         sh:class      rdfs:Resource ;
                         sh:predicate  sh:arg1
                       ] ;
        sh:returnType  xsd:integer ;
        sh:sparql      "\n\t\t# The SUM will fail with an error if one of the operands is not a number\n\t\t# (this mechanism is used to propagate errors from sh:hasShape calls)\n\t\tSELECT (SUM(?s) AS ?result)\n\t\tWHERE {\n\t\t\tGRAPH $arg3 {\n\t\t\t\t$arg2 rdf:rest*/rdf:first ?shape .\n\t\t\t}\n\t\t\tBIND (sh:hasShape($arg1, ?shape, $arg3, true) AS ?hasShape) .\n\t\t\tBIND (IF(bound(?hasShape), IF(?hasShape = ?arg4, 1, 0), 'error') AS ?s) .\n\t\t}\n\t\t" .

sh:maxExclusive  a  rdf:Property ;
        rdfs:label  "max exclusive" .

sh:arg8  a          rdf:Property ;
        rdfs:label  "arg8" .

sh:InversePropertyValueConstraintTemplate
        a                sh:ShapeClass ;
        rdfs:comment     "A constraint template that validates all subjects of triples that have the given focus node as object and the given predicate." ;
        rdfs:label       "Inverse property value constraint template" ;
        rdfs:subClassOf  sh:AbstractValidationConstraintTemplate .

sh:hasDatatype  a        sh:Function ;
        rdfs:comment     "Checks whether a given node (?value) is a literal with a given datatype (?datatype). If the datatype is sh:text, then the function will either accept xsd:string or rdf:langString." ;
        rdfs:label       "has datatype" ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment  "The datatype that the node must have." ;
                           sh:class      rdfs:Datatype ;
                           sh:predicate  sh:datatype
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "\n\t\tASK {\n\t\t\t{\n\t\t\t\tFILTER isLiteral($value) .\n\t\t\t} .\n\t\t\tBIND (datatype($value) AS ?valueDatatype) .\n\t\t\tFILTER ((?valueDatatype = $datatype) || ($datatype = sh:text && ?valueDatatype IN (rdf:langString, xsd:string))) .\n\t\t}\n\t\t" .

sh:AbstractMaxInclusiveNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Specifies an (inclusive) maximum value for literal nodes." ;
        rdfs:label             "Abstract max inclusive constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The inclusive maximum value permitted: ?value <= ?maxInclusive" ;
                                 rdfs:label                "max inclusive" ;
                                 sh:nodeKind               sh:Literal ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:maxInclusive
                               ] ;
        sh:message             "Must be less than or equal to {?maxInclusive}" ;
        sh:validationFunction  sh:hasMaxInclusive .

sh:hasClass  a           sh:Function ;
        rdfs:comment     "Checks whether a given node ($value) is an instance of a given class ($class) or its subclasses. Returns false if the value is a literal. Returns true if $class is rdfs:Resource. Returns true if $class is rdf:List and $value has a rdf:first value." ;
        rdfs:label       "has class" ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment  "The type that the node must have." ;
                           sh:class      rdfs:Class ;
                           sh:index      1 ;
                           sh:predicate  sh:class
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "\n\t\tASK {\n\t\t\tFILTER (isIRI($value) || isBlank($value)) .\n\t\t\tFILTER (\n\t\t\t\t$class = rdfs:Resource ||\n\t\t\t\t($class = rdf:List && EXISTS { $value rdf:first ?any }) ||\n\t\t\t\tEXISTS { $value rdf:type/rdfs:subClassOf* $class }\n\t\t\t\t)\n\t\t}\n\t\t" .

sh:ClassShape  a       sh:Shape ;
        sh:property    [ rdfs:comment  "True to indicate that this class is not expected to have direct instances." ;
                         rdfs:label    "abstract" ;
                         sh:datatype   xsd:boolean ;
                         sh:maxCount   1 ;
                         sh:predicate  sh:abstract
                       ] ;
        sh:scopeClass  rdfs:Class .

sh:AbstractDerivedPropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "Points at a template that wraps an executable body (e.g. a SPARQL query) that computes all values for the given property." ;
                           rdfs:label                "derived values" ;
                           sh:class                  sh:DerivedValuesTemplate ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:derivedValues
                         ] .

xsd:integer  a           rdfs:Datatype ;
        rdfs:label       "integer" ;
        rdfs:subClassOf  rdfs:Literal .

sh:isIn  a               sh:Function ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment  "The graph containing the rdf:List." ;
                           rdfs:label    "shapes graph" ;
                           sh:index      2 ;
                           sh:nodeKind   sh:IRI ;
                           sh:predicate  sh:shapesGraph
                         ] ;
        sh:argument      [ rdfs:comment  "The rdf:List containing the allowed values." ;
                           rdfs:label    "in" ;
                           sh:class      rdf:List ;
                           sh:index      1 ;
                           sh:predicate  sh:in
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "\n\t\tASK {\n\t\t\tFILTER EXISTS {\n\t\t\t\tGRAPH $shapesGraph {\n\t\t\t\t\t$in (rdf:rest*)/rdf:first $value .\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t" .

sh:AbstractQualifiedCountPropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Base class for qualified min and max count constraints, declaring the shared argument sh:qualifiedValueShape." ;
        rdfs:label       "Abstract qualified count property constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "The shape that the values must have." ;
                           rdfs:label                "qualified value shape" ;
                           sh:class                  sh:Shape ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:qualifiedValueShape
                         ] .

sh:arg3  a          rdf:Property ;
        rdfs:label  "arg3" .

sh:AbstractClassNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Enforces a constraint that all focus nodes must be of a certain type. For resources this will accept instances of subclasses." ;
        rdfs:label             "Abstract class node constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The type that all focus nodes must have, based on the semantics defined by the function sh:hasClass." ;
                                 rdfs:label                "class" ;
                                 sh:class                  rdfs:Class ;
                                 sh:nodeKind               sh:IRI ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:class
                               ] ;
        sh:message             "Must be instances of {?class}" ;
        sh:validationFunction  sh:hasClass .

sh:PropertyConstraint
        a                 sh:ConstraintTemplate ;
        rdfs:comment      "Declares the structural constraints for a property at the associated class. The supported arguments are inherited from the superclasses." ;
        rdfs:label        "Property constraint" ;
        rdfs:subClassOf   sh:AbstractMaxLengthPropertyConstraint , sh:AbstractQualifiedMaxCountPropertyConstraint , sh:AbstractQualifiedMinCountPropertyConstraint , sh:AbstractInPropertyConstraint , sh:AbstractHasValuePropertyConstraint , sh:AbstractMinCountPropertyConstraint , sh:AbstractDirectTypePropertyConstraint , sh:AbstractUniqueLangPropertyConstraint , sh:AbstractMaxExclusivePropertyConstraint , sh:AbstractDatatypePropertyConstraint , sh:AbstractNodeKindPropertyConstraint , sh:AbstractPatternPropertyConstraint , sh:AbstractMinInclusivePropertyConstraint , sh:AbstractDerivedPropertyConstraint , sh:AbstractMinExclusivePropertyConstraint , sh:AbstractMinLengthPropertyConstraint , sh:AbstractValueShapePropertyConstraint , sh:AbstractMaxInclusivePropertyConstraint , sh:AbstractMaxCountPropertyConstraint , sh:AbstractClassPropertyConstraint ;
        sh:constraint     [ a             sh:SPARQLConstraint ;
                            sh:message    "Property constraints cannot have both datatype and class or directType." ;
                            sh:predicate  sh:datatype ;
                            sh:sparql     "\n\t\t\tSELECT $this\n\t\t\tWHERE {\n\t\t\t\tFILTER EXISTS {\n\t\t\t\t\t$this sh:datatype $datatype .\n\t\t\t\t\t$this sh:class|sh:directType ?any .\n\t\t\t\t}\n\t\t\t}\n\t\t\t"
                          ] ;
        sh:labelTemplate  "Property {?predicate} : {?datatype}{?class} [{?minCount}..{?maxCount}]" ;
        sh:property       [ rdfs:comment  "A default value that could be used to pre-populate input forms etc. This has no formal meaning otherwise." ;
                            rdfs:label    "default value" ;
                            sh:maxCount   1 ;
                            sh:predicate  sh:defaultValue
                          ] .

sh:NativeConstraint  a   sh:ShapeClass ;
        rdfs:comment     "A constraint that has a native executable body attached with it." ;
        rdfs:label       "Native constraint" ;
        rdfs:subClassOf  sh:Constraint ;
        sh:abstract      true ;
        sh:property      [ rdfs:comment  "Result annotations provide information about additional properties that the constructed constraint violations shall have." ;
                           rdfs:label    "result annotation" ;
                           sh:class      sh:ResultAnnotation ;
                           sh:predicate  sh:resultAnnotation
                         ] ;
        sh:property      [ rdfs:comment  "A human-readable explanation of this constraint. May have multiple values for different languages." ;
                           rdfs:label    "comment" ;
                           sh:datatype   sh:text ;
                           sh:predicate  rdfs:comment
                         ] ;
        sh:property      [ rdfs:comment  "Specifies the default sh:message(s) to produce for any constraint violation. May have multiple values for different languages." ;
                           rdfs:label    "message" ;
                           sh:datatype   sh:text ;
                           sh:predicate  sh:message
                         ] .

sh:optionalWhenInherited
        a           rdf:Property ;
        rdfs:label  "optional when inherited" .

sh:GraphShape  a       sh:Shape ;
        rdfs:comment   "Defines a couple of properties that are applicable to graphs. In the absence of a custom SHACL class such as sh:Graph, this shape applies to owl:Ontology which also holds owl:imports triples." ;
        rdfs:label     "Graph shape" ;
        sh:property    [ rdfs:comment  "Links a graph with other graphs that shall be included into the shapes graph that contains shape and template definitions as well as the SHACL metamodel." ;
                         rdfs:label    "shapes graph" ;
                         sh:class      rdfs:Resource ;
                         sh:predicate  sh:shapesGraph
                       ] ;
        sh:property    [ rdfs:comment  "Links a graph with an entailment regime that its shape definitions shall be evaluated with." ;
                         rdfs:label    "entailment" ;
                         sh:class      rdfs:Resource ;
                         sh:nodeKind   sh:IRI ;
                         sh:predicate  sh:entailment
                       ] ;
        sh:scopeClass  owl:Ontology .

sh:sourceShape  a   rdf:Property ;
        rdfs:label  "source shape" .

rdfs:comment  a     rdf:Property ;
        rdfs:label  "comment" .

sh:defaultValue  a  rdf:Property ;
        rdfs:label  "default value" .

sh:InversePropertyScope
        a                sh:ScopeTemplate ;
        rdfs:comment     "A scope that includes all objects that have at least one value for a given predicate." ;
        rdfs:label       "Inverse property scope" ;
        rdfs:subClassOf  sh:TemplateScope ;
        sh:argument      [ rdfs:comment  "The property to look for." ;
                           rdfs:label    "predicate" ;
                           sh:class      rdf:Property ;
                           sh:predicate  sh:predicate
                         ] ;
        sh:sparql        "\n\t\tSELECT DISTINCT ?this\n\t\tWHERE {\n\t\t\t?any $predicate ?this .\n\t\t}\n\t\t" .

sh:Argument  a            sh:ConstraintTemplate ;
        rdfs:comment      "Declares an argument that gets mapped to a variable in the parameterized SPARQL query." ;
        rdfs:label        "Argument" ;
        rdfs:subClassOf   sh:AbstractClassPropertyConstraint , sh:AbstractOptionalArgumentConstraint , sh:AbstractNodeKindPropertyConstraint , sh:AbstractDatatypePropertyConstraint ;
        sh:constraint     [ a             sh:SPARQLConstraint ;
                            sh:message    "Arguments cannot have both ?datatype and ?class" ;
                            sh:predicate  sh:datatype ;
                            sh:sparql     "\n\t\t\tSELECT *\n\t\t\tWHERE {\n\t\t\t\tFILTER EXISTS {\n\t\t\t\t\t$this sh:datatype ?value1 .\n\t\t\t\t\t$this sh:class ?value2 .\n\t\t\t\t}\n\t\t\t}\n\t\t\t"
                          ] ;
        sh:labelTemplate  "Argument {?predicate} : {?datatype}{?class}" ;
        sh:message        "Arguments cannot have more than one value." ;
        sh:property       [ rdfs:comment     "The index of this argument, especially to determine the order of arguments in a function call. Values should be 0, 1, 2 etc. The default index for sh:arg1 is 0 etc." ;
                            rdfs:label       "index" ;
                            sh:datatype      xsd:integer ;
                            sh:maxCount      1 ;
                            sh:minInclusive  0 ;
                            sh:predicate     sh:index
                          ] ;
        sh:sparql         "\n\t\tSELECT $this ($this AS ?subject) $predicate\n\t\tWHERE {\n\t\t\tFILTER EXISTS {\n\t\t\t\t$this $predicate ?value1 .\n\t\t\t\t$this $predicate ?value2 .\n\t\t\t\tFILTER (?value1 != ?value2) .\n\t\t\t}\n\t\t}\n\t\t" .

sh:PropertyValueConstraintTemplate
        a                sh:ShapeClass ;
        rdfs:comment     "A constraint template that validates all objects of triples that have the given focus node as subject and the given predicate." ;
        rdfs:label       "Property value constraint template" ;
        rdfs:subClassOf  sh:AbstractValidationConstraintTemplate .

rdf:langString  a        rdfs:Datatype ;
        rdfs:label       "string with language" ;
        rdfs:subClassOf  rdfs:Literal .

sh:AbstractValueShapePropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Enforces a constraint that all values of the property must have a certain shape." ;
        rdfs:label       "Abstract value shape property constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "The shape that the values must have." ;
                           rdfs:label                "value shape" ;
                           sh:class                  sh:Shape ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:valueShape
                         ] ;
        sh:message       "Value does not fulfill the constraints of shape {?valueShape}" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?subject) $predicate ?object ?failure\n\t\tWHERE {\n\t\t\t$this $predicate ?object .\n\t\t\tBIND (sh:hasShape(?object, $valueShape, $shapesGraph, false) AS ?hasShape) .\n\t\t\tBIND (!bound(?hasShape) AS ?failure) .\n\t\t\tFILTER (?failure || !?hasShape) .\n\t\t}\n\t\t" .

sh:hasMinInclusive  a    sh:Function ;
        rdfs:comment     "Checks whether a given node (?value) has value greater than or equal to (>=) the provided ?minInclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types." ;
        rdfs:label       "has min inclusive" ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment  "The permitted inclusive minimum value" ;
                           rdfs:label    "min inclusive" ;
                           sh:nodeKind   sh:Literal ;
                           sh:predicate  sh:minInclusive
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "ASK { FILTER ($value >= $minInclusive) }" .

sh:AbstractDerivedInversePropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "Points at a template that wraps an executable body (e.g. a SPARQL query) that computes all values for the given inverse property." ;
                           rdfs:label                "derived values" ;
                           sh:class                  sh:DerivedValuesTemplate ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:derivedValues
                         ] .

sh:sourceTemplate  a  rdf:Property ;
        rdfs:label  "source template" .

sh:Constraint  a         sh:ShapeClass ;
        rdfs:comment     "An abstract superclass of constraints. Constraints are either template calls or \"native\" constraints with an executable body." ;
        rdfs:label       "Constraint" ;
        rdfs:subClassOf  rdfs:Resource ;
        sh:abstract      true ;
        sh:property      [ rdfs:comment  "Specifies the severity to use for any constraint violation produced by this constraint. Defaults to sh:Violation for native constraints. For template constraints it uses the severity of the template by default." ;
                           rdfs:label    "severity" ;
                           sh:class      sh:Severity ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:severity
                         ] ;
        sh:property      [ rdfs:comment  "Links a constraint to Shapes that the tested nodes need to fulfill before the constraint is evaluated." ;
                           rdfs:label    "filter shape" ;
                           sh:class      sh:Shape ;
                           sh:predicate  sh:filterShape
                         ] .

sh:AbstractDatatypePropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Enforces a constraint that all values of the property must be literals of a certain datatype. This will accept strings with language tags instead of xsd:string." ;
        rdfs:label             "Abstract datatype property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The datatype that all values of the property must have. sh:text is recommended if the values shall be either strings or string with language tags." ;
                                 rdfs:label                "datatype" ;
                                 sh:class                  rdfs:Datatype ;
                                 sh:nodeKind               sh:IRI ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:datatype
                               ] ;
        sh:message             "Values must have datatype {?datatype}" ;
        sh:validationFunction  sh:hasDatatype .

sh:qualifiedMinCount  a  rdf:Property ;
        rdfs:label  "qualified min count" .

sh:ScopeTemplate  a      sh:ShapeClass ;
        rdfs:comment     "A template that is used to compute a scope." ;
        rdfs:label       "Scope template" ;
        rdfs:subClassOf  sh:Template .

xsd:time  a              rdfs:Datatype ;
        rdfs:label       "time" ;
        rdfs:subClassOf  rdfs:Literal .

sh:scope  a         rdf:Property ;
        rdfs:label  "scope" .

xsd:float  a             rdfs:Datatype ;
        rdfs:label       "float" ;
        rdfs:subClassOf  rdfs:Literal .

sh:NodeConstraintTemplate
        a                sh:ShapeClass ;
        rdfs:comment     "A constraint template that validates the focus node using the validation function." ;
        rdfs:label       "Node constraint template" ;
        rdfs:subClassOf  sh:AbstractValidationConstraintTemplate .

sh:NodeKind  a           sh:ShapeClass ;
        rdfs:comment     "The class of RDF node kinds: blank nodes, IRIs and literals." ;
        rdfs:label       "Node kind" ;
        rdfs:subClassOf  rdfs:Resource ;
        sh:constraint    [ sh:in  ( sh:BlankNode sh:IRI sh:Literal ) ] .

sh:maxLength  a     rdf:Property ;
        rdfs:label  "max length" .

sh:maxCount  a      rdf:Property ;
        rdfs:label  "max count" .

sh:DerivedValuesTemplate
        a                sh:ShapeClass ;
        rdfs:comment     "The class of templates that can be used to derive (property) values." ;
        rdfs:label       "Derived values template" ;
        rdfs:subClassOf  sh:Template .

sh:arg9  a          rdf:Property ;
        rdfs:label  "arg9" .

sh:AllSubjectsScope  a   sh:ScopeTemplate ;
        rdfs:comment     "A scope that includes all subjects in the graph." ;
        rdfs:label       "All subjects scope" ;
        rdfs:subClassOf  sh:TemplateScope ;
        sh:sparql        "\n\t\tSELECT DISTINCT ?this\n\t\tWHERE {\n\t\t\t?this ?anyPredicate ?anyObject .\n\t\t}\n\t\t" .

rdf:type  a         rdf:Property ;
        rdfs:label  "type" .

xsd:decimal  a           rdfs:Datatype ;
        rdfs:label       "decimal" ;
        rdfs:subClassOf  rdfs:Literal .

sh:AndConstraint  a       sh:ConstraintTemplate ;
        rdfs:comment      "Enforces a constraint that all of the provided shapes must be valid for the focus resource." ;
        rdfs:label        "And constraint" ;
        rdfs:subClassOf   sh:TemplateConstraint ;
        sh:argument       [ rdfs:comment  "A list of shapes that will be validated." ;
                            rdfs:label    "shapes" ;
                            sh:class      rdf:List ;
                            sh:predicate  sh:shapes
                          ] ;
        sh:labelTemplate  "And constraint: {?shapes}" ;
        sh:message        "Violation of AND constraint" ;
        sh:sparql         "\n\t\tSELECT $this ?failure\n\t\tWHERE {\n\t\t\tBIND (sh:countShapesWithMatchResult($this, $shapes, $shapesGraph, false) AS ?count)\n\t\t\tBIND (!bound(?count) AS ?failure) .\n\t\t\tFILTER IF(?failure, true, ?count > 0) .\n\t\t}\n\t\t" .

sh:Info  a            sh:Severity ;
        rdfs:comment  "The severity of informational results." ;
        rdfs:label    "Info" .

sh:Closed  a          sh:ClosedShapeConstraint ;
        rdfs:comment  "A singleton instance of sh:ClosedShapeConstraint that can be shared between multiple shape definitions." ;
        rdfs:label    "Closed" .

sh:SPARQLExecutable  a   sh:ShapeClass ;
        rdfs:subClassOf  rdfs:Class ;
        sh:property      [ rdfs:comment  "The SPARQL query to execute." ;
                           rdfs:label    "SPARQL" ;
                           sh:datatype   xsd:string ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:sparql
                         ] .

sh:shape  a                  rdf:Property ;
        rdfs:label           "shape" ;
        sh:defaultValueType  sh:Shape .

sh:TemplateConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "A constraint that is instantiating a template." ;
        rdfs:label       "Template constraint" ;
        rdfs:subClassOf  sh:Constraint ;
        sh:abstract      true .

sh:scopeClass  a    rdf:Property ;
        rdfs:label  "scope class" .

sh:Scope  a              rdfs:Class ;
        rdfs:comment     "An abstract superclass of scopes. Scopes are either template calls or native scopes with an executable body." ;
        rdfs:label       "Scope" ;
        rdfs:subClassOf  rdfs:Resource ;
        sh:abstract      true .

sh:AbstractInInversePropertyConstraint
        a                      sh:InversePropertyValueConstraintTemplate ;
        rdfs:comment           "Specifies the allowed values for an inverse property by pointing to a List of nodes." ;
        rdfs:label             "Abstract in inverse property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The rdf:List containing the allowed values of the inverse property." ;
                                 rdfs:label                "in" ;
                                 sh:class                  rdf:List ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:in
                               ] ;
        sh:message             "Value is not one of the allowed values" ;
        sh:validationFunction  sh:isIn .

rdfs:Datatype  a         rdfs:Class ;
        rdfs:comment     "The class of RDF datatypes." ;
        rdfs:label       "Datatype" ;
        rdfs:subClassOf  rdfs:Class .

sh:ValidationFunctions
        a                sh:Function ;
        rdfs:comment     "The recommended abstract superclass for all validation functions that take a value as an argument and return a boolean result (true if the value is OK)." ;
        rdfs:label       "Validation functions" ;
        rdfs:subClassOf  rdfs:Resource ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment  "The value to validate." ;
                           sh:index      0 ;
                           sh:predicate  sh:value
                         ] .

sh:arg4  a          rdf:Property ;
        rdfs:label  "arg4" .

sh:hasPattern  a         sh:Function ;
        rdfs:comment     "Checks whether the string representation of a given node (?value) matches a given regular expression (?pattern). Returns false if the value is a blank node." ;
        rdfs:label       "has pattern" ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment  "The optional flags." ;
                           sh:datatype   xsd:string ;
                           sh:index      2 ;
                           sh:optional   true ;
                           sh:predicate  sh:flags
                         ] ;
        sh:argument      [ rdfs:comment  "The regular expression to match." ;
                           sh:datatype   xsd:string ;
                           sh:index      1 ;
                           sh:predicate  sh:pattern
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "ASK { FILTER (!isBlank($value) && IF(bound($flags), regex(str($value), $pattern, $flags), regex(str($value), $pattern))) }" .

sh:defaultValueType  a  rdf:Property ;
        rdfs:label  "default value type" .

sh:AbstractMaxLengthPropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Specifies the maximum string length of values." ;
        rdfs:label             "Abstract max length property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The maximum string length permitted for values of this property." ;
                                 rdfs:label                "max length" ;
                                 sh:datatype               xsd:integer ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:maxLength
                               ] ;
        sh:message             "Invalid string length." ;
        sh:validationFunction  sh:hasMaxLength .

rdfs:label  a       rdf:Property ;
        rdfs:label  "label" .

sh:argument  a               rdf:Property ;
        rdfs:label           "argument" ;
        sh:defaultValueType  sh:Argument .

sh:Shape  a              sh:ShapeClass ;
        rdfs:comment     "The class of shapes." ;
        rdfs:label       "Shape" ;
        rdfs:subClassOf  rdfs:Resource ;
        sh:property      [ rdfs:comment  "Links a Shape to a class, establishing that all instances of that class are expected to have this shape." ;
                           rdfs:label    "scope class" ;
                           sh:class      rdfs:Class ;
                           sh:predicate  sh:scopeClass
                         ] ;
        sh:property      [ rdfs:comment  "Links a Shape to other Shapes that the tested nodes need to fulfill before the constraints of the shape are evaluated." ;
                           rdfs:label    "filter shape" ;
                           sh:class      sh:Shape ;
                           sh:predicate  sh:filterShape
                         ] ;
        sh:property      [ rdfs:comment  "Declares that a given incoming reference property is relevant for matching resources." ;
                           rdfs:label    "inverse property" ;
                           sh:class      sh:InversePropertyConstraint ;
                           sh:predicate  sh:inverseProperty
                         ] ;
        sh:property      [ rdfs:comment  "Declares that a given property is relevant for matching resources." ;
                           rdfs:label    "property" ;
                           sh:class      sh:PropertyConstraint ;
                           sh:predicate  sh:property
                         ] ;
        sh:property      [ rdfs:comment  "Links a Shape to Scopes that produce the focus nodes that the shape applies to." ;
                           rdfs:label    "scope" ;
                           sh:class      sh:Scope ;
                           sh:predicate  sh:scope
                         ] ;
        sh:property      [ rdfs:comment  "Defines arbitrary constraints on the matching resources. Use sh:property for structural property declarations." ;
                           rdfs:label    "constraint" ;
                           sh:class      sh:Constraint ;
                           sh:predicate  sh:constraint
                         ] .

sh:NotEqualConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Reports an error for any pair of equal values of the two properties, for the same focus node." ;
        rdfs:label       "Not equal property pair constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyPairConstraint ;
        sh:message       "Values of {?predicate1} and {?predicate2} must not be equal" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?subject) ($predicate1 AS ?predicate) ?object\n\t\tWHERE {\n\t\t\t$this $predicate1 ?object .\n\t\t\t$this $predicate2 ?object .\n\t\t}\n\t\t" .

sh:AbstractMinCountPropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Enforces a constraint on the minimum cardinality of the property." ;
        rdfs:label       "Abstract min count property constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "The minimum number of values that the property must have." ;
                           rdfs:label                "min count" ;
                           sh:datatype               xsd:integer ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:minCount
                         ] ;
        sh:message       "Required minimum value count {$minCount} but found {?count}" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?subject) $predicate ?count\n\t\tWHERE {\n\t\t\tBIND (sh:valueCount($this, $predicate) AS ?count) .\n\t\t\tFILTER (?count < $minCount) .\n\t\t}\n\t\t" .

sh:filterShape  a            rdf:Property ;
        rdfs:label           "filter shape" ;
        sh:defaultValueType  sh:Shape .

sh:hasMaxInclusive  a    sh:Function ;
        rdfs:comment     "Checks whether a given node (?value) has value less than or equal to (<=) the provided ?maxInclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types." ;
        rdfs:label       "has max inclusive" ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment  "The permitted inclusive maximum value" ;
                           rdfs:label    "max inclusive" ;
                           sh:nodeKind   sh:Literal ;
                           sh:predicate  sh:maxInclusive
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "ASK { FILTER ($value <= $maxInclusive) }" .

sh:nodeKind  a      rdf:Property ;
        rdfs:label  "node kind" .

sh:SPARQLScope  a        sh:ShapeClass ;
        rdfs:comment     "A scope that has a SPARQL body attached to it." ;
        rdfs:label       "SPARQL scope" ;
        rdfs:subClassOf  sh:SPARQLExecutable , sh:NativeScope .

sh:abstract  a      rdf:Property ;
        rdfs:label  "abstract" .

sh:AbstractHasValuePropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Specifies that the given property must have the specified value (it may also have others)." ;
        rdfs:label       "Abstract has value property constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "The required value of the property." ;
                           rdfs:label                "has value" ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:hasValue
                         ] ;
        sh:message       "Missing expected value {?hasValue}" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?subject) $predicate\n\t\tWHERE {\n\t\t\tFILTER NOT EXISTS { $this $predicate $hasValue }\n\t\t}\n\t\t" .

sh:hasMinLength  a       sh:Function ;
        rdfs:comment     "Checks whether a given string (?value) has a length within a given minimum string length." ;
        rdfs:label       "has min length" ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment  "The minimum string length." ;
                           rdfs:label    "min length" ;
                           sh:datatype   xsd:integer ;
                           sh:index      1 ;
                           sh:predicate  sh:minLength
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "\n\t\tASK {\n\t\t\tBIND (STRLEN(str($value)) AS ?valueLength) .\n\t\t\tFILTER (bound(?valueLength) && ?valueLength >= $minLength) .\n\t\t}\n\t\t" .

sh:NodeConstraint  a     sh:ConstraintTemplate ;
        rdfs:label       "Node constraint" ;
        rdfs:subClassOf  sh:AbstractDatatypeNodeConstraint , sh:AbstractPatternNodeConstraint , sh:AbstractMaxExclusiveNodeConstraint , sh:AbstractMinInclusiveNodeConstraint , sh:AbstractMaxInclusiveNodeConstraint , sh:AbstractMaxLengthNodeConstraint , sh:AbstractMinLengthNodeConstraint , sh:AbstractMinExclusiveNodeConstraint , sh:AbstractInNodeConstraint , sh:AbstractNodeKindNodeConstraint , sh:AbstractClassNodeConstraint , sh:AbstractDirectTypeNodeConstraint ;
        sh:constraint    [ a           sh:SPARQLConstraint ;
                           sh:message  "Node constraints cannot have both datatype and class or directType." ;
                           sh:sparql   "\n\t\t\tSELECT $this ($this AS ?subject) (sh:datatype AS ?predicate) ($datatype AS ?object)\n\t\t\tWHERE {\n\t\t\t\tFILTER EXISTS {\n\t\t\t\t\t$this sh:datatype $datatype .\n\t\t\t\t\t$this sh:class|sh:directType ?any .\n\t\t\t\t}\n\t\t\t}\n\t\t\t"
                         ] .

sh:AbstractMaxExclusiveNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Specifies an (exclusive) maximum value for literal nodes." ;
        rdfs:label             "Abstract max exclusive constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The exclusive maximum value permitted: ?value < ?maxExclusive" ;
                                 rdfs:label                "max exclusive" ;
                                 sh:nodeKind               sh:Literal ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:maxExclusive
                               ] ;
        sh:message             "Values must be less than {?maxExclusive}" ;
        sh:validationFunction  sh:hasMaxExclusive .

xsd:boolean  a           rdfs:Datatype ;
        rdfs:label       "boolean" ;
        rdfs:subClassOf  rdfs:Literal .

sh:sparql  a        rdf:Property ;
        rdfs:label  "SPARQL" .

sh:AbstractMinInclusiveNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Specifies an (inclusive) minimum value for literal nodes." ;
        rdfs:label             "Abstract min inclusive constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The inclusive minimum value permitted: ?value >= ?minInclusive" ;
                                 rdfs:label                "min inclusive" ;
                                 sh:nodeKind               sh:Literal ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:minInclusive
                               ] ;
        sh:message             "Must be greater than or equal to {?minInclusive}" ;
        sh:validationFunction  sh:hasMinInclusive .

sh:optional  a      rdf:Property ;
        rdfs:label  "optional" .

sh:minInclusive  a  rdf:Property ;
        rdfs:label  "min inclusive" .

sh:minLength  a     rdf:Property ;
        rdfs:label  "min length" .

sh:ShapeClass  a         rdfs:Class ;
        rdfs:comment     "The metaclass for classes that are also shapes. This is syntactic sugar for declaring an instance of both rdfs:Class and sh:Shape." ;
        rdfs:label       "Shape class" ;
        rdfs:subClassOf  sh:Shape , rdfs:Class .

rdfs:Class  a            rdfs:Class ;
        rdfs:comment     "The class of classes." ;
        rdfs:label       "Class" ;
        rdfs:subClassOf  rdfs:Resource .

sh:Severity  a           sh:ShapeClass ;
        rdfs:comment     "The class of severities. Consists of exactly: sh:Info, sh:Warning, sh:Violation." ;
        rdfs:label       "Severity" ;
        rdfs:subClassOf  rdfs:Resource .

rdfs:subClassOf  a  rdf:Property ;
        rdfs:label  "subClassOf" .

sh:ClosedShapeConstraint
        a                 sh:ConstraintTemplate ;
        rdfs:comment      "Triggers an error for each triple of the focus node that has a predicate that is not explicitly enumerated using sh:property in the surrounding shape." ;
        rdfs:label        "Closed shape constraint" ;
        rdfs:subClassOf   sh:TemplateConstraint ;
        sh:argument       [ rdfs:comment  "A List of predicates that are permitted regardless of whether they have been declared as sh:property. Could be used to allow sh:nodeShape or rdf:type." ;
                            rdfs:label    "ignored properties" ;
                            sh:class      rdf:List ;
                            sh:optional   true ;
                            sh:predicate  sh:ignoredProperties
                          ] ;
        sh:labelTemplate  "Closed shape" ;
        sh:message        "Invalid triple for closed shape" ;
        sh:sparql         "\n\t\tSELECT $this ($this AS ?subject) ?predicate ?object\n\t\tWHERE {\n\t\t\t$this ?predicate ?object .\n\t\t\tFILTER (NOT EXISTS {\n\t\t\t\tGRAPH $shapesGraph {\n\t\t\t\t\t$currentShape sh:property/sh:predicate ?predicate .\n\t\t\t\t}\n\t\t\t} && (!bound($ignoredProperties) || NOT EXISTS {\n\t\t\t\tGRAPH $shapesGraph {\n\t\t\t\t\t$ignoredProperties rdf:rest*/rdf:first ?predicate .\n\t\t\t\t}\n\t\t\t}))\n\t\t}\t\n\t\t" .

sh:shapesGraph  a   rdf:Property ;
        rdfs:label  "shapes graph" .

sh:AbstractPropertyPairConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Shared superclass for templates that take two predicates as some of their arguments." ;
        rdfs:label       "Abstract property pair constraint" ;
        rdfs:subClassOf  sh:TemplateConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment  "The second Property being constrained." ;
                           rdfs:label    "predicate 2" ;
                           sh:class      rdf:Property ;
                           sh:predicate  sh:predicate2
                         ] ;
        sh:argument      [ rdfs:comment  "The first Property being constrained." ;
                           rdfs:label    "predicate 1" ;
                           sh:class      rdf:Property ;
                           sh:predicate  sh:predicate1
                         ] ;
        sh:constraint    [ a              sh:NotEqualConstraint ;
                           rdfs:comment   "The two predicates must not be equal" ;
                           sh:predicate1  sh:predicate1 ;
                           sh:predicate2  sh:predicate2
                         ] .

sh:AbstractQualifiedMaxCountPropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Enforces a constraint that a maximum number of values of the property can have a certain shape." ;
        rdfs:label       "Abstract qualified max count property constraint" ;
        rdfs:subClassOf  sh:AbstractQualifiedCountPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "The maximum number of values that can have the shape." ;
                           rdfs:label                "qualified max count" ;
                           sh:datatype               xsd:integer ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:qualifiedMaxCount
                         ] ;
        sh:message       "Violation of qualified value shape constraint {$qualifiedValueShape}: expected at most {$qualifiedMaxCount}, found {?count}" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?subject) $predicate ?count ?failure\n\t\tWHERE {\n\t\t\tBIND (sh:valuesWithShapeCount($this, $predicate, $qualifiedValueShape, $shapesGraph) AS ?count) .\n\t\t\tBIND (!bound(?count) AS ?failure) .\n\t\t\tFILTER IF(?failure, true, ?count > $qualifiedMaxCount) .\n\t\t}\n\t\t" .

sh:shapes  a        rdf:Property ;
        rdfs:label  "shapes" .

sh:AbstractValueShapeInversePropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Enforces a constraint that all inverse values of the property must have a certain shape." ;
        rdfs:label       "Abstract value shape inverse property constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "The shape that the inverse values must have." ;
                           rdfs:label                "value shape" ;
                           sh:class                  sh:Shape ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:valueShape
                         ] ;
        sh:message       "Inverse value does not fulfill the constraints of shape {?valueShape}" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?object) $predicate ?subject ?failure\n\t\tWHERE {\n\t\t\t?subject $predicate $this .\n\t\t\tBIND (sh:hasShape(?subject, $valueShape, $shapesGraph, false) AS ?hasShape) .\n\t\t\tBIND (!bound(?hasShape) AS ?failure) .\n\t\t\tFILTER (?failure || !?hasShape) .\n\t\t}\n\t\t" .

sh:AbstractPatternPropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Specifies a regular expression that all values of the property need to match." ;
        rdfs:label             "Abstract pattern property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The optional flags." ;
                                 rdfs:label                "flags" ;
                                 sh:datatype               xsd:string ;
                                 sh:optional               true ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:flags
                               ] ;
        sh:argument            [ rdfs:comment              "The (regular expression) pattern for values of this property." ;
                                 rdfs:label                "pattern" ;
                                 sh:datatype               xsd:string ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:pattern
                               ] ;
        sh:message             "Values must match the pattern {?pattern}" ;
        sh:validationFunction  sh:hasPattern .

sh:ValidationResult  a   sh:ShapeClass ;
        rdfs:comment     "A validation result." ;
        rdfs:label       "Validation Result" ;
        rdfs:subClassOf  sh:AbstractResult .

sh:index  a         rdf:Property ;
        rdfs:label  "index" .

sh:AbstractPropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Shared superclass for templates that take a predicate as one of their arguments." ;
        rdfs:label       "Abstract property constraint" ;
        rdfs:subClassOf  sh:TemplateConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment  "The property being constrained." ;
                           rdfs:label    "predicate" ;
                           sh:class      rdf:Property ;
                           sh:predicate  sh:predicate
                         ] ;
        sh:property      [ rdfs:comment  "A description of the role of the predicate to users. Multiple values (for different languages) are supported." ;
                           rdfs:label    "comment" ;
                           sh:datatype   sh:text ;
                           sh:predicate  rdfs:comment
                         ] ;
        sh:property      [ rdfs:comment  "A display label for input forms etc. By default, the global rdfs:label of the predicate should be used. Multiple values (for different languages) are supported." ;
                           rdfs:label    "label" ;
                           sh:datatype   sh:text ;
                           sh:predicate  rdfs:label
                         ] .

rdf:Property  a          rdfs:Class ;
        rdfs:comment     "The class of RDF properties." ;
        rdfs:label       "Property" ;
        rdfs:subClassOf  rdfs:Resource .

sh:value  a         rdf:Property ;
        rdfs:label  "value" .

sh:TemplateScope  a      sh:ScopeTemplate ;
        rdfs:comment     "A scope that is instantiating a template." ;
        rdfs:label       "Scope constraint" ;
        rdfs:subClassOf  sh:Scope ;
        sh:abstract      true .

sh:constraint  a             rdf:Property ;
        rdfs:label           "constraint" ;
        sh:defaultValueType  sh:NodeConstraint .

sh:arg5  a          rdf:Property ;
        rdfs:label  "arg5" .

sh:minCount  a      rdf:Property ;
        rdfs:label  "min count" .

sh:AbstractResult  a     sh:ShapeClass ;
        rdfs:comment     "Instances of subclasses of this class can be constructed during constraint validation." ;
        rdfs:label       "Abstract Result" ;
        rdfs:subClassOf  rdfs:Resource ;
        sh:abstract      true ;
        sh:property      [ rdfs:comment  "Can link a result with other results that provide more details. This is especially useful to describe violations against nested patterns or shapes." ;
                           rdfs:label    "detail" ;
                           sh:class      sh:AbstractResult ;
                           sh:predicate  sh:detail
                         ] ;
        sh:property      [ rdfs:comment  "The Template that caused this result." ;
                           rdfs:label    "source template" ;
                           sh:class      sh:ConstraintTemplate ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:sourceTemplate
                         ] ;
        sh:property      [ rdfs:comment  "The subject of triples involved in this result." ;
                           rdfs:label    "subject" ;
                           sh:class      rdfs:Resource ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:subject
                         ] ;
        sh:property      [ rdfs:comment  "A human-readable message explaining the cause of the result. Multiple values are possible assuming they have different languages." ;
                           rdfs:label    "message" ;
                           sh:datatype   sh:text ;
                           sh:predicate  sh:message
                         ] ;
        sh:property      [ rdfs:comment  "The Shape that caused this result." ;
                           rdfs:label    "source shape" ;
                           sh:class      sh:Shape ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:sourceShape
                         ] ;
        sh:property      [ rdfs:comment  "The predicate of triples involved in this result." ;
                           rdfs:label    "predicate" ;
                           sh:class      rdf:Property ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:predicate
                         ] ;
        sh:property      [ rdfs:comment  "The object of triples involved in this result." ;
                           rdfs:label    "object" ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:object
                         ] ;
        sh:property      [ rdfs:comment  "The severity of the result, derived from the source constraint." ;
                           rdfs:label    "severity" ;
                           sh:class      sh:Severity ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:severity
                         ] ;
        sh:property      [ rdfs:comment  "The focus node evaluated when the result was produced." ;
                           rdfs:label    "focus node" ;
                           sh:class      rdfs:Resource ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:focusNode
                         ] ;
        sh:property      [ rdfs:comment  "The Constraint that caused this result." ;
                           rdfs:label    "source constraint" ;
                           sh:class      sh:Constraint ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:sourceConstraint
                         ] .

sh:AbstractDirectTypePropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Enforces a constraint that all values of the property must be of a certain (direct) type. In contrast to sh:class this does not include instances of subclasses." ;
        rdfs:label             "Abstract direct type property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The type that all values of the property must have, excluding subclasses." ;
                                 rdfs:label                "direct type" ;
                                 sh:class                  rdfs:Class ;
                                 sh:nodeKind               sh:IRI ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:directType
                               ] ;
        sh:message             "Values must be direct instances of {?directType}" ;
        sh:validationFunction  sh:hasDirectType .

sh:LessThanOrEqualConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Reports an error for any pair of values of the two properties for the same focus node, where the first value is not less than or equal to the second value." ;
        rdfs:label       "Less than or equal property pair constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyPairConstraint ;
        sh:message       "Values of {?predicate1} must be less than or equal to the values of {?predicate2}" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?subject) ($predicate1 AS ?predicate) ?object\n\t\tWHERE {\n\t\t\t$this $predicate1 ?object .\n\t\t\t$this $predicate2 ?object2 .\n\t\t\tFILTER (!(?object <= ?object2)) .\n\t\t}\n\t\t" .

sh:AbstractNodeKindNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Specifies the valid node kind of the focus node." ;
        rdfs:label             "Abstract node kind node constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The node kind that all focus nodes must be of." ;
                                 rdfs:label                "node kind" ;
                                 sh:class                  sh:NodeKind ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:nodeKind
                               ] ;
        sh:message             "Must be of kind {?nodeKind}" ;
        sh:validationFunction  sh:hasNodeKind .

sh:SPARQLConstraint  a   sh:ShapeClass ;
        rdfs:comment     "A constraint that has a SPARQL body attached with it." ;
        rdfs:label       "SPARQL constraint" ;
        rdfs:subClassOf  sh:SPARQLExecutable , sh:NativeConstraint .

sh:in   a           rdf:Property ;
        rdfs:label  "in" .

sh:nodeShape  a       rdf:Property ;
        rdfs:comment  "Links a resource with the shapes that it is supposed to have. All values of this property must be IRI nodes." ;
        rdfs:label    "node shape" ;
        rdfs:range    sh:Shape .

xsd:string  a            rdfs:Datatype ;
        rdfs:label       "string" ;
        rdfs:subClassOf  rdfs:Literal .

sh:predicate1  a             rdf:Property ;
        rdfs:label           "predicate 1" ;
        sh:defaultValueType  rdf:Property .

rdf:List  a              rdfs:Class ;
        rdfs:comment     "The class of RDF Lists." ;
        rdfs:label       "List" ;
        rdfs:subClassOf  rdfs:Resource .

sh:AbstractInNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Specifies the allowed values by pointing to a List of nodes." ;
        rdfs:label             "Abstract in node constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The rdf:List containing the allowed values of the property." ;
                                 rdfs:label                "in" ;
                                 sh:class                  rdf:List ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:in
                               ] ;
        sh:message             "Value is not one of the allowed values" ;
        sh:validationFunction  sh:isIn .

sh:AbstractNodeKindPropertyConstraint
        a                      sh:PropertyValueConstraintTemplate ;
        rdfs:comment           "Specifies the valid node kind of a property." ;
        rdfs:label             "Abstract node kind property constraint" ;
        rdfs:subClassOf        sh:AbstractPropertyConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The node kind that all values of the property must be of." ;
                                 rdfs:label                "node kind" ;
                                 sh:class                  sh:NodeKind ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:nodeKind
                               ] ;
        sh:message             "Values must be of kind {?nodeKind}" ;
        sh:validationFunction  sh:hasNodeKind .

sh:AbstractMinCountInversePropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Enforces a constraint on the minimum cardinality of an incoming property." ;
        rdfs:label       "Abstract min count inverse property constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "The minimum number of values that the inverse property can have." ;
                           rdfs:label                "min count" ;
                           sh:datatype               xsd:integer ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:minCount
                         ] ;
        sh:message       "Inverse property must have at least {$minCount} values, but found {?count}" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?object) $predicate ?count\n\t\tWHERE {\n\t\t\tBIND (sh:inverseValueCount($this, $predicate) AS ?count) .\n\t\t\tFILTER (?count < $maxCount) .\n\t\t}\n\t\t" .

sh:Template  a           sh:ShapeClass ;
        rdfs:comment     "A macro that acts as an abstraction of a (reusable) SPARQL query. The query can be parameterized by the supplied arguments." ;
        rdfs:label       "Template" ;
        rdfs:subClassOf  sh:SPARQLExecutable , sh:Macro ;
        sh:abstract      true ;
        sh:property      [ rdfs:comment  "Outlines how human-readable labels of instances of this template class shall be produced. The values must be strings that can contain {?argName} as placeholders for the actual values of the given argument. There may be multiple values, for different languages." ;
                           rdfs:label    "label template" ;
                           sh:datatype   sh:text ;
                           sh:predicate  sh:labelTemplate
                         ] .

sh:maxInclusive  a  rdf:Property ;
        rdfs:label  "max inclusive" .

sh:datatype  a      rdf:Property ;
        rdfs:label  "datatype" .

sh:member  a        rdf:Property ;
        rdfs:label  "member" .

sh:resultAnnotation  a  rdf:Property ;
        rdfs:label  "result annotation" .

sh:text  a               rdfs:Datatype ;
        rdfs:comment     "The union of xsd:string and rdf:langString, to be used in cases where a property can either be a string or a string with a language tag. This type should never be used directly as the type of literals." ;
        rdfs:label       "text" ;
        rdfs:subClassOf  rdfs:Literal .

sh:InversePropertyConstraint
        a                 sh:ConstraintTemplate ;
        rdfs:comment      "Declares the structural constraints for an incoming property at the associated class. The supported arguments are inherited from the superclasses." ;
        rdfs:label        "Inverse property constraint" ;
        rdfs:subClassOf   sh:AbstractClassInversePropertyConstraint , sh:AbstractInInversePropertyConstraint , sh:AbstractValueShapeInversePropertyConstraint , sh:AbstractMaxCountInversePropertyConstraint , sh:AbstractMinCountInversePropertyConstraint , sh:AbstractDerivedInversePropertyConstraint ;
        sh:labelTemplate  "Inverse property {?predicate} : {?class} [{?minCount}..{?maxCount}]" .

sh:class  a         rdf:Property ;
        rdfs:label  "class" .

sh:BlankNode  a       sh:NodeKind ;
        rdfs:comment  "The node kind of all blank nodes." ;
        rdfs:label    "Blank node" .

sh:predicate  a              rdf:Property ;
        rdfs:label           "predicate" ;
        sh:defaultValueType  rdf:Property .

sh:uniqueLang  a    rdf:Property ;
        rdfs:label  "unique language" .

sh:hasMinExclusive  a    sh:Function ;
        rdfs:comment     "Checks whether a given node (?value) has value greater than (>) the provided ?minExclusive. Returns false if this cannot be determined, e.g. because values do not have comparable types." ;
        rdfs:label       "has min exclusive" ;
        rdfs:subClassOf  sh:ValidationFunctions ;
        sh:argument      [ rdfs:comment  "The permitted exclusive minimum value" ;
                           rdfs:label    "min exclusive" ;
                           sh:nodeKind   sh:Literal ;
                           sh:predicate  sh:minExclusive
                         ] ;
        sh:returnType    xsd:boolean ;
        sh:sparql        "ASK { FILTER ($value > $minExclusive) }" .

sh:message  a       rdf:Property ;
        rdfs:label  "message" .

sh:AbstractDirectTypeNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Enforces a constraint that the focus nodes must be of a certain (direct) type. In contrast to sh:class this does not include instances of subclasses." ;
        rdfs:label             "Abstract direct type node constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The type that all values of the property must have, excluding subclasses." ;
                                 rdfs:label                "direct value type" ;
                                 sh:class                  rdfs:Class ;
                                 sh:nodeKind               sh:IRI ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:directType
                               ] ;
        sh:message             "Must be direct instances of {?directType}" ;
        sh:validationFunction  sh:hasDirectType .

sh:ConstraintTemplate
        a                sh:ShapeClass ;
        rdfs:comment     "A template that is used for constraint validation." ;
        rdfs:label       "Constraint template" ;
        rdfs:subClassOf  sh:Template ;
        sh:property      [ rdfs:comment  "Result annotations provide information about additional properties that the constructed constraint violations shall have." ;
                           rdfs:label    "result annotation" ;
                           sh:class      sh:ResultAnnotation ;
                           sh:predicate  sh:resultAnnotation
                         ] ;
        sh:property      [ rdfs:comment  "Specifies the default sh:predicate to produce for validation results." ;
                           rdfs:label    "predicate" ;
                           sh:class      rdf:Property ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:predicate
                         ] ;
        sh:property      [ rdfs:comment  "Specifies the default sh:message(s) to produce for validation results. May have multiple values for different languages." ;
                           rdfs:label    "message" ;
                           sh:datatype   sh:text ;
                           sh:predicate  sh:message
                         ] ;
        sh:property      [ rdfs:comment  "Specifies the default sh:severity to produce for validation results." ;
                           rdfs:label    "severity" ;
                           sh:class      sh:Severity ;
                           sh:maxCount   1 ;
                           sh:predicate  sh:severity
                         ] .

sh:AllObjectsScope  a    sh:ScopeTemplate ;
        rdfs:comment     "A scope that includes all objects in the graph." ;
        rdfs:label       "All objects scope" ;
        rdfs:subClassOf  sh:TemplateScope ;
        sh:sparql        "\n\t\tSELECT DISTINCT ?this\n\t\tWHERE {\n\t\t\t?anySubject ?anyPredicate ?this .\n\t\t}\n\t\t" .

sh:DefaultValueTypeRule
        a             sh:Template ;
        rdfs:comment  "A template encapsulating a query that can be used to construct rdf:type triples for certain untyped blank nodes that are an object in a triple where the predicate has a sh:defaultValueType. This can be used as a pre-processor for shape graphs before they are validated." ;
        rdfs:label    "default value type inference rule" ;
        sh:sparql     "\n\t\tCONSTRUCT {\n\t\t\t?node a ?defaultValueType .\n\t\t}\n\t\tWHERE {\n\t\t\t?predicate sh:defaultValueType ?defaultValueType .\n\t\t\t?anySubject ?predicate ?node .\n\t\t\tFILTER (NOT EXISTS { ?node a ?anyType }) .\n\t\t}\n\t\t" .

sh:AbstractMaxLengthNodeConstraint
        a                      sh:NodeConstraintTemplate ;
        rdfs:comment           "Specifies the maximum string length of nodes." ;
        rdfs:label             "Abstract max length node constraint" ;
        rdfs:subClassOf        sh:TemplateConstraint ;
        sh:abstract            true ;
        sh:argument            [ rdfs:comment              "The maximum string length permitted for the focus nodes." ;
                                 rdfs:label                "max length" ;
                                 sh:datatype               xsd:integer ;
                                 sh:optionalWhenInherited  true ;
                                 sh:predicate              sh:maxLength
                               ] ;
        sh:message             "Invalid string length." ;
        sh:validationFunction  sh:hasMaxLength .

sh:arg6  a          rdf:Property ;
        rdfs:label  "arg6" .

sh:EqualConstraint  a    sh:ConstraintTemplate ;
        rdfs:comment     "Reports an error for any value of predicate 1 that is not also a value of predicate 2 and vice-versa, for the same focus node." ;
        rdfs:label       "Equal property pair constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyPairConstraint ;
        sh:message       "Value sets of {?predicate1} and {?predicate2} must be equal" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?subject) ?predicate ?object\n\t\tWHERE {\n\t\t\t{\n\t\t\t\t$this $predicate1 ?object .\n\t\t\t\tFILTER NOT EXISTS {\n\t\t\t\t\t$this $predicate2 ?object .\n\t\t\t\t}\n\t\t\t\tBIND ($predicate1 AS ?predicate) .\n\t\t\t}\n\t\t\tUNION\n\t\t\t{\n\t\t\t\t$this $predicate2 ?object .\n\t\t\t\tFILTER NOT EXISTS {\n\t\t\t\t\t$this $predicate1 ?object .\n\t\t\t\t}\n\t\t\t\tBIND ($predicate2 AS ?predicate) .\n\t\t\t}\n\t\t}\n\t\t" .

sh:inverseProperty  a        rdf:Property ;
        rdfs:label           "inverse property" ;
        sh:defaultValueType  sh:InversePropertyConstraint .

sh:Literal  a         sh:NodeKind ;
        rdfs:comment  "The node kind of all literals." ;
        rdfs:label    "Literal" .

sh:OrConstraint  a        sh:ConstraintTemplate ;
        rdfs:comment      "Enforces a constraint that at least one of several provided shapes must be valid for the focus resource." ;
        rdfs:label        "Or constraint" ;
        rdfs:subClassOf   sh:TemplateConstraint ;
        sh:argument       [ rdfs:comment  "A list of shapes that will be validated." ;
                            rdfs:label    "shapes" ;
                            sh:class      rdf:List ;
                            sh:predicate  sh:shapes
                          ] ;
        sh:labelTemplate  "Or constraint: {?shapes}" ;
        sh:message        "Violation of OR constraint" ;
        sh:sparql         "\n\t\tSELECT $this ?failure\n\t\tWHERE {\n\t\t\tBIND (sh:countShapesWithMatchResult($this, $shapes, $shapesGraph, true) AS ?count)\n\t\t\tBIND (!bound(?count) AS ?failure) .\n\t\t\tFILTER IF(?failure, true, ?count = 0) .\n\t\t}\n\t\t" .

sh:AbstractMaxCountInversePropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Enforces a constraint on the maximum cardinality of an incoming property." ;
        rdfs:label       "Abstract max count inverse property constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "The maximum number of values that the inverse property can have." ;
                           rdfs:label                "max count" ;
                           sh:datatype               xsd:integer ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:maxCount
                         ] ;
        sh:message       "Inverse property must have at most {$maxCount} values, but found {?count}" ;
        sh:sparql        "\n\t\tSELECT $this ($this AS ?object) $predicate ?count\n\t\tWHERE {\n\t\t\tBIND (sh:inverseValueCount($this, $predicate) AS ?count) .\n\t\t\tFILTER (?count > $maxCount) .\n\t\t}\n\t\t" .

sh:valueShape  a             rdf:Property ;
        rdfs:label           "value shape" ;
        sh:defaultValueType  sh:Shape .

sh:focusNode  a     rdf:Property ;
        rdfs:label  "focus node" .

sh:AbstractUniqueLangPropertyConstraint
        a                sh:ConstraintTemplate ;
        rdfs:comment     "Specifies that no pair of values can have the same language tag." ;
        rdfs:label       "Abstract unique language property constraint" ;
        rdfs:subClassOf  sh:AbstractPropertyConstraint ;
        sh:abstract      true ;
        sh:argument      [ rdfs:comment              "True to activate the constraint that no pair of values can have the same language tag." ;
                           rdfs:label                "unique lang" ;
                           sh:datatype               xsd:boolean ;
                           sh:optionalWhenInherited  true ;
                           sh:predicate              sh:uniqueLang
                         ] ;
        sh:message       "Duplicate use of language tag \"{?lang}\"" ;
        sh:sparql        "\n\t\tSELECT DISTINCT $this ($this AS ?subject) $predicate ?lang\n\t\tWHERE {\n\t\t\t{\n\t\t\t\tFILTER ($uniqueLang) .\n\t\t\t}\n\t\t\t$this $predicate ?value .\n\t\t\tBIND (lang(?value) AS ?lang) .\n\t\t\tFILTER (bound(?lang) && ?lang != \"\") . \n\t\t\tFILTER EXISTS {\n\t\t\t\t$this $predicate ?otherValue .\n\t\t\t\tFILTER (?otherValue != ?value && ?lang = lang(?otherValue)) .\n\t\t\t}\n\t\t}\n\t\t" .

sh:returnType  a    rdf:Property ;
        rdfs:label  "return type" .

sh:hasShape  a         sh:Function ;
        rdfs:comment   "Validates whether a given resource (?arg1) fulfills all error-level constraints defined for a given shape (?arg2). This creates a (possibly recursive) constraint validator equivalent to the validateNodeAgainstShape operation. The function returns an error, i.e. no result, if the validation could not be completed, e.g. due to an unsupported recursion or an unsupported extension language. Therefore the function should not be called inside of FILTER statements directly, but rather with BIND." ;
        rdfs:label     "has shape" ;
        sh:argument    [ rdfs:comment  "If set to true then any recursive occurrence of the same resource against the same shape will fail (result=undefined)." ;
                         sh:datatype   xsd:boolean ;
                         sh:optional   true ;
                         sh:predicate  sh:arg4
                       ] ;
        sh:argument    [ rdfs:comment  "The graph containing the shape definitions." ;
                         sh:nodeKind   sh:IRI ;
                         sh:predicate  sh:arg3
                       ] ;
        sh:argument    [ rdfs:comment  "The shape containing the constraints that need to be validated." ;
                         sh:class      sh:Shape ;
                         sh:predicate  sh:arg2
                       ] ;
        sh:argument    [ rdfs:comment  "The resource to validate." ;
                         sh:class      rdfs:Resource ;
                         sh:predicate  sh:arg1
                       ] ;
        sh:returnType  xsd:boolean .

schema:Person  a         sh:ShapeClass ;
        rdfs:label       "Person" ;
        rdfs:subClassOf  rdfs:Resource ;
        sh:property      [ rdfs:comment  "Zero or more email addresses of the person." ;
                           rdfs:label    "email" ;
                           sh:datatype   xsd:string ;
                           sh:predicate  schema:email
                         ] .

ex:InvalidSquare  a  ex:Square ;
        rdfs:label  "Invalid square" ;
        ex:creator  ex:PersonWithoutEmail ;
        ex:height   8 ;
        ex:width    9 .

ex:computeArea  a      sh:Function ;
        rdfs:comment   "Computes the area of a given rectangle (?arg1) as the product of its width and height." ;
        rdfs:label     "compute area" ;
        sh:argument    [ rdfs:comment  "The rectangle whose area to compute." ;
                         sh:class      ex:Rectangle ;
                         sh:predicate  sh:arg1
                       ] ;
        sh:returnType  xsd:integer ;
        sh:sparql      "\n\t\tSELECT ((?width * ?height) AS ?result)\n\t\tWHERE {\n\t\t\t?arg1 ex:width ?width .\n\t\t\t?arg1 ex:height ?height .\n\t\t}\n\t\t" .

ex:Rectangle  a          sh:ShapeClass ;
        rdfs:label       "Rectangle" ;
        rdfs:subClassOf  rdfs:Resource ;
        sh:constraint    [ a             ex:PositivePropertyValueConstraint ;
                           arg:property  ex:width
                         ] ;
        sh:constraint    [ a             ex:PositivePropertyValueConstraint ;
                           arg:property  ex:height
                         ] ;
        sh:property      [ rdfs:comment  "The width of the Rectangle." ;
                           rdfs:label    "width" ;
                           sh:datatype   xsd:integer ;
                           sh:maxCount   1 ;
                           sh:minCount   1 ;
                           sh:predicate  ex:width
                         ] ;
        sh:property      [ rdfs:comment  "The height of the Rectangle." ;
                           rdfs:label    "height" ;
                           sh:datatype   xsd:integer ;
                           sh:maxCount   1 ;
                           sh:minCount   1 ;
                           sh:predicate  ex:height
                         ] ;
        sh:property      [ rdfs:comment   "The creator of the Rectangle." ;
                           rdfs:label     "creator" ;
                           sh:class       schema:Person ;
                           sh:maxCount    1 ;
                           sh:predicate   ex:creator ;
                           sh:valueShape  [ sh:property  [ sh:minCount   1 ;
                                                           sh:predicate  schema:email
                                                         ] ]
                         ] .

ex:PositivePropertyValueConstraint
        a                 sh:ConstraintTemplate ;
        rdfs:comment      "A template that can be used to define a SHACL constraint on a given property (arg:property) to make sure that the values of that property are > 0." ;
        rdfs:label        "Positive property value constraint" ;
        rdfs:subClassOf   sh:TemplateConstraint ;
        sh:argument       [ rdfs:comment  "The property to constrain (e.g. ex:width or ex:height)." ;
                            rdfs:label    "property" ;
                            sh:class      rdfs:Resource ;
                            sh:predicate  arg:property
                          ] ;
        sh:labelTemplate  "Values of property {?property} must be > 0" ;
        sh:message        "Property {?property} must only have positive values, but found {?object}" ;
        sh:sparql         "\n\t\tSELECT ?this (?this AS ?subject) (?property AS ?predicate) ?object ?property\n\t\tWHERE {\n\t\t\t?this ?property ?object .\n\t\t\tFILTER (?object <= 0) .\n\t\t}\n\t\t" .

ex:Square  a             sh:ShapeClass ;
        rdfs:label       "Square" ;
        rdfs:subClassOf  ex:Rectangle ;
        sh:constraint    [ a             sh:SPARQLConstraint ;
                           sh:message    "Width and height of a Square must be equal" ;
                           sh:predicate  ex:width ;
                           sh:sparql     "\n\t\t\tSELECT ?this (?this AS ?subject) (?width AS ?object)\n\t\t\tWHERE {\n\t\t\t\t?this ex:width ?width .\n\t\t\t\t?this ex:height ?height .\n\t\t\t\tFILTER (?width != ?height) .\n\t\t\t}\n\t\t\t"
                         ] .

ex:PersonWithoutEmail
        a       schema:Person .

ex:TestRectangle  a  ex:Rectangle ;
        rdfs:label  "Test rectangle" ;
        ex:creator  ex:PersonWithEmail ;
        ex:height   6 ;
        ex:width    7 .

<http://topbraid.org/examples/shaclsquare>
        a               sh:Graph ;
        rdfs:comment    "A simple example model demonstrating some key features of SHACL. Have a look at the ex:computeArea function, the rule attached to ex:Rectangle and the constraint attached to ex:Square." ;
        rdfs:label      "SHACL Square Example" ;
        sh:shapesGraph  <http://www.w3.org/ns/shacl> .

ex:PersonWithEmail  a  schema:Person ;
        schema:email  "john@example.com" .
